import {
  require_react
} from "./chunk-3KJI4LAA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/howler/dist/howler.js
var require_howler = __commonJS({
  "node_modules/howler/dist/howler.js"(exports) {
    (function() {
      "use strict";
      var HowlerGlobal2 = function() {
        this.init();
      };
      HowlerGlobal2.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var self = this || Howler2;
          self._counter = 1e3;
          self._html5AudioPool = [];
          self.html5PoolSize = 10;
          self._codecs = {};
          self._howls = [];
          self._muted = false;
          self._volume = 1;
          self._canPlayEvent = "canplaythrough";
          self._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
          self.masterGain = null;
          self.noAudio = false;
          self.usingWebAudio = true;
          self.autoSuspend = true;
          self.ctx = null;
          self.autoUnlock = true;
          self._setup();
          return self;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(vol) {
          var self = this || Howler2;
          vol = parseFloat(vol);
          if (!self.ctx) {
            setupAudioContext();
          }
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            self._volume = vol;
            if (self._muted) {
              return self;
            }
            if (self.usingWebAudio) {
              self.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            }
            for (var i2 = 0; i2 < self._howls.length; i2++) {
              if (!self._howls[i2]._webAudio) {
                var ids = self._howls[i2]._getSoundIds();
                for (var j2 = 0; j2 < ids.length; j2++) {
                  var sound = self._howls[i2]._soundById(ids[j2]);
                  if (sound && sound._node) {
                    sound._node.volume = sound._volume * vol;
                  }
                }
              }
            }
            return self;
          }
          return self._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(muted) {
          var self = this || Howler2;
          if (!self.ctx) {
            setupAudioContext();
          }
          self._muted = muted;
          if (self.usingWebAudio) {
            self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler2.ctx.currentTime);
          }
          for (var i2 = 0; i2 < self._howls.length; i2++) {
            if (!self._howls[i2]._webAudio) {
              var ids = self._howls[i2]._getSoundIds();
              for (var j2 = 0; j2 < ids.length; j2++) {
                var sound = self._howls[i2]._soundById(ids[j2]);
                if (sound && sound._node) {
                  sound._node.muted = muted ? true : sound._muted;
                }
              }
            }
          }
          return self;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          var self = this || Howler2;
          for (var i2 = 0; i2 < self._howls.length; i2++) {
            self._howls[i2].stop();
          }
          return self;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          var self = this || Howler2;
          for (var i2 = self._howls.length - 1; i2 >= 0; i2--) {
            self._howls[i2].unload();
          }
          if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== "undefined") {
            self.ctx.close();
            self.ctx = null;
            setupAudioContext();
          }
          return self;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(ext) {
          return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var self = this || Howler2;
          self.state = self.ctx ? self.ctx.state || "suspended" : "suspended";
          self._autoSuspend();
          if (!self.usingWebAudio) {
            if (typeof Audio !== "undefined") {
              try {
                var test = new Audio();
                if (typeof test.oncanplaythrough === "undefined") {
                  self._canPlayEvent = "canplay";
                }
              } catch (e2) {
                self.noAudio = true;
              }
            } else {
              self.noAudio = true;
            }
          }
          try {
            var test = new Audio();
            if (test.muted) {
              self.noAudio = true;
            }
          } catch (e2) {
          }
          if (!self.noAudio) {
            self._setupCodecs();
          }
          return self;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var self = this || Howler2;
          var audioTest = null;
          try {
            audioTest = typeof Audio !== "undefined" ? new Audio() : null;
          } catch (err) {
            return self;
          }
          if (!audioTest || typeof audioTest.canPlayType !== "function") {
            return self;
          }
          var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
          var ua = self._navigator ? self._navigator.userAgent : "";
          var checkOpera = ua.match(/OPR\/(\d+)/g);
          var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
          var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
          var safariVersion = ua.match(/Version\/(.*?) /);
          var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
          self._codecs = {
            mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!mpegTest,
            opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
          };
          return self;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var self = this || Howler2;
          if (self._audioUnlocked || !self.ctx) {
            return;
          }
          self._audioUnlocked = false;
          self.autoUnlock = false;
          if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
            self._mobileUnloaded = true;
            self.unload();
          }
          self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
          var unlock = function(e2) {
            while (self._html5AudioPool.length < self.html5PoolSize) {
              try {
                var audioNode = new Audio();
                audioNode._unlocked = true;
                self._releaseHtml5Audio(audioNode);
              } catch (e3) {
                self.noAudio = true;
                break;
              }
            }
            for (var i2 = 0; i2 < self._howls.length; i2++) {
              if (!self._howls[i2]._webAudio) {
                var ids = self._howls[i2]._getSoundIds();
                for (var j2 = 0; j2 < ids.length; j2++) {
                  var sound = self._howls[i2]._soundById(ids[j2]);
                  if (sound && sound._node && !sound._node._unlocked) {
                    sound._node._unlocked = true;
                    sound._node.load();
                  }
                }
              }
            }
            self._autoResume();
            var source = self.ctx.createBufferSource();
            source.buffer = self._scratchBuffer;
            source.connect(self.ctx.destination);
            if (typeof source.start === "undefined") {
              source.noteOn(0);
            } else {
              source.start(0);
            }
            if (typeof self.ctx.resume === "function") {
              self.ctx.resume();
            }
            source.onended = function() {
              source.disconnect(0);
              self._audioUnlocked = true;
              document.removeEventListener("touchstart", unlock, true);
              document.removeEventListener("touchend", unlock, true);
              document.removeEventListener("click", unlock, true);
              document.removeEventListener("keydown", unlock, true);
              for (var i3 = 0; i3 < self._howls.length; i3++) {
                self._howls[i3]._emit("unlock");
              }
            };
          };
          document.addEventListener("touchstart", unlock, true);
          document.addEventListener("touchend", unlock, true);
          document.addEventListener("click", unlock, true);
          document.addEventListener("keydown", unlock, true);
          return self;
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var self = this || Howler2;
          if (self._html5AudioPool.length) {
            return self._html5AudioPool.pop();
          }
          var testPlay = new Audio().play();
          if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
            testPlay.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
          }
          return new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(audio) {
          var self = this || Howler2;
          if (audio._unlocked) {
            self._html5AudioPool.push(audio);
          }
          return self;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var self = this;
          if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          for (var i2 = 0; i2 < self._howls.length; i2++) {
            if (self._howls[i2]._webAudio) {
              for (var j2 = 0; j2 < self._howls[i2]._sounds.length; j2++) {
                if (!self._howls[i2]._sounds[j2]._paused) {
                  return self;
                }
              }
            }
          }
          if (self._suspendTimer) {
            clearTimeout(self._suspendTimer);
          }
          self._suspendTimer = setTimeout(function() {
            if (!self.autoSuspend) {
              return;
            }
            self._suspendTimer = null;
            self.state = "suspending";
            var handleSuspension = function() {
              self.state = "suspended";
              if (self._resumeAfterSuspend) {
                delete self._resumeAfterSuspend;
                self._autoResume();
              }
            };
            self.ctx.suspend().then(handleSuspension, handleSuspension);
          }, 3e4);
          return self;
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var self = this;
          if (!self.ctx || typeof self.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          if (self.state === "running" && self.ctx.state !== "interrupted" && self._suspendTimer) {
            clearTimeout(self._suspendTimer);
            self._suspendTimer = null;
          } else if (self.state === "suspended" || self.state === "running" && self.ctx.state === "interrupted") {
            self.ctx.resume().then(function() {
              self.state = "running";
              for (var i2 = 0; i2 < self._howls.length; i2++) {
                self._howls[i2]._emit("resume");
              }
            });
            if (self._suspendTimer) {
              clearTimeout(self._suspendTimer);
              self._suspendTimer = null;
            }
          } else if (self.state === "suspending") {
            self._resumeAfterSuspend = true;
          }
          return self;
        }
      };
      var Howler2 = new HowlerGlobal2();
      var Howl2 = function(o2) {
        var self = this;
        if (!o2.src || o2.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        self.init(o2);
      };
      Howl2.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(o2) {
          var self = this;
          if (!Howler2.ctx) {
            setupAudioContext();
          }
          self._autoplay = o2.autoplay || false;
          self._format = typeof o2.format !== "string" ? o2.format : [o2.format];
          self._html5 = o2.html5 || false;
          self._muted = o2.mute || false;
          self._loop = o2.loop || false;
          self._pool = o2.pool || 5;
          self._preload = typeof o2.preload === "boolean" || o2.preload === "metadata" ? o2.preload : true;
          self._rate = o2.rate || 1;
          self._sprite = o2.sprite || {};
          self._src = typeof o2.src !== "string" ? o2.src : [o2.src];
          self._volume = o2.volume !== void 0 ? o2.volume : 1;
          self._xhr = {
            method: o2.xhr && o2.xhr.method ? o2.xhr.method : "GET",
            headers: o2.xhr && o2.xhr.headers ? o2.xhr.headers : null,
            withCredentials: o2.xhr && o2.xhr.withCredentials ? o2.xhr.withCredentials : false
          };
          self._duration = 0;
          self._state = "unloaded";
          self._sounds = [];
          self._endTimers = {};
          self._queue = [];
          self._playLock = false;
          self._onend = o2.onend ? [{ fn: o2.onend }] : [];
          self._onfade = o2.onfade ? [{ fn: o2.onfade }] : [];
          self._onload = o2.onload ? [{ fn: o2.onload }] : [];
          self._onloaderror = o2.onloaderror ? [{ fn: o2.onloaderror }] : [];
          self._onplayerror = o2.onplayerror ? [{ fn: o2.onplayerror }] : [];
          self._onpause = o2.onpause ? [{ fn: o2.onpause }] : [];
          self._onplay = o2.onplay ? [{ fn: o2.onplay }] : [];
          self._onstop = o2.onstop ? [{ fn: o2.onstop }] : [];
          self._onmute = o2.onmute ? [{ fn: o2.onmute }] : [];
          self._onvolume = o2.onvolume ? [{ fn: o2.onvolume }] : [];
          self._onrate = o2.onrate ? [{ fn: o2.onrate }] : [];
          self._onseek = o2.onseek ? [{ fn: o2.onseek }] : [];
          self._onunlock = o2.onunlock ? [{ fn: o2.onunlock }] : [];
          self._onresume = [];
          self._webAudio = Howler2.usingWebAudio && !self._html5;
          if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
            Howler2._unlockAudio();
          }
          Howler2._howls.push(self);
          if (self._autoplay) {
            self._queue.push({
              event: "play",
              action: function() {
                self.play();
              }
            });
          }
          if (self._preload && self._preload !== "none") {
            self.load();
          }
          return self;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var self = this;
          var url = null;
          if (Howler2.noAudio) {
            self._emit("loaderror", null, "No audio support.");
            return;
          }
          if (typeof self._src === "string") {
            self._src = [self._src];
          }
          for (var i2 = 0; i2 < self._src.length; i2++) {
            var ext, str;
            if (self._format && self._format[i2]) {
              ext = self._format[i2];
            } else {
              str = self._src[i2];
              if (typeof str !== "string") {
                self._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              ext = /^data:audio\/([^;,]+);/i.exec(str);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              }
            }
            if (!ext) {
              console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
            }
            if (ext && Howler2.codecs(ext)) {
              url = self._src[i2];
              break;
            }
          }
          if (!url) {
            self._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          self._src = url;
          self._state = "loading";
          if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
            self._html5 = true;
            self._webAudio = false;
          }
          new Sound2(self);
          if (self._webAudio) {
            loadBuffer(self);
          }
          return self;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(sprite, internal) {
          var self = this;
          var id = null;
          if (typeof sprite === "number") {
            id = sprite;
            sprite = null;
          } else if (typeof sprite === "string" && self._state === "loaded" && !self._sprite[sprite]) {
            return null;
          } else if (typeof sprite === "undefined") {
            sprite = "__default";
            if (!self._playLock) {
              var num = 0;
              for (var i2 = 0; i2 < self._sounds.length; i2++) {
                if (self._sounds[i2]._paused && !self._sounds[i2]._ended) {
                  num++;
                  id = self._sounds[i2]._id;
                }
              }
              if (num === 1) {
                sprite = null;
              } else {
                id = null;
              }
            }
          }
          var sound = id ? self._soundById(id) : self._inactiveSound();
          if (!sound) {
            return null;
          }
          if (id && !sprite) {
            sprite = sound._sprite || "__default";
          }
          if (self._state !== "loaded") {
            sound._sprite = sprite;
            sound._ended = false;
            var soundId = sound._id;
            self._queue.push({
              event: "play",
              action: function() {
                self.play(soundId);
              }
            });
            return soundId;
          }
          if (id && !sound._paused) {
            if (!internal) {
              self._loadQueue("play");
            }
            return sound._id;
          }
          if (self._webAudio) {
            Howler2._autoResume();
          }
          var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1e3);
          var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3 - seek);
          var timeout = duration * 1e3 / Math.abs(sound._rate);
          var start = self._sprite[sprite][0] / 1e3;
          var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3;
          sound._sprite = sprite;
          sound._ended = false;
          var setParams = function() {
            sound._paused = false;
            sound._seek = seek;
            sound._start = start;
            sound._stop = stop;
            sound._loop = !!(sound._loop || self._sprite[sprite][2]);
          };
          if (seek >= stop) {
            self._ended(sound);
            return;
          }
          var node = sound._node;
          if (self._webAudio) {
            var playWebAudio = function() {
              self._playLock = false;
              setParams();
              self._refreshBuffer(sound);
              var vol = sound._muted || self._muted ? 0 : sound._volume;
              node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              sound._playStart = Howler2.ctx.currentTime;
              if (typeof node.bufferSource.start === "undefined") {
                sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
              } else {
                sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
              }
              if (timeout !== Infinity) {
                self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
              }
              if (!internal) {
                setTimeout(function() {
                  self._emit("play", sound._id);
                  self._loadQueue();
                }, 0);
              }
            };
            if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
              playWebAudio();
            } else {
              self._playLock = true;
              self.once("resume", playWebAudio);
              self._clearTimer(sound._id);
            }
          } else {
            var playHtml5 = function() {
              node.currentTime = seek;
              node.muted = sound._muted || self._muted || Howler2._muted || node.muted;
              node.volume = sound._volume * Howler2.volume();
              node.playbackRate = sound._rate;
              try {
                var play = node.play();
                if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                  self._playLock = true;
                  setParams();
                  play.then(function() {
                    self._playLock = false;
                    node._unlocked = true;
                    if (!internal) {
                      self._emit("play", sound._id);
                    } else {
                      self._loadQueue();
                    }
                  }).catch(function() {
                    self._playLock = false;
                    self._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    sound._ended = true;
                    sound._paused = true;
                  });
                } else if (!internal) {
                  self._playLock = false;
                  setParams();
                  self._emit("play", sound._id);
                }
                node.playbackRate = sound._rate;
                if (node.paused) {
                  self._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                if (sprite !== "__default" || sound._loop) {
                  self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                } else {
                  self._endTimers[sound._id] = function() {
                    self._ended(sound);
                    node.removeEventListener("ended", self._endTimers[sound._id], false);
                  };
                  node.addEventListener("ended", self._endTimers[sound._id], false);
                }
              } catch (err) {
                self._emit("playerror", sound._id, err);
              }
            };
            if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
              node.src = self._src;
              node.load();
            }
            var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
            if (node.readyState >= 3 || loadedNoReadyState) {
              playHtml5();
            } else {
              self._playLock = true;
              self._state = "loading";
              var listener = function() {
                self._state = "loaded";
                playHtml5();
                node.removeEventListener(Howler2._canPlayEvent, listener, false);
              };
              node.addEventListener(Howler2._canPlayEvent, listener, false);
              self._clearTimer(sound._id);
            }
          }
          return sound._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(id) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "pause",
              action: function() {
                self.pause(id);
              }
            });
            return self;
          }
          var ids = self._getSoundIds(id);
          for (var i2 = 0; i2 < ids.length; i2++) {
            self._clearTimer(ids[i2]);
            var sound = self._soundById(ids[i2]);
            if (sound && !sound._paused) {
              sound._seek = self.seek(ids[i2]);
              sound._rateSeek = 0;
              sound._paused = true;
              self._stopFade(ids[i2]);
              if (sound._node) {
                if (self._webAudio) {
                  if (!sound._node.bufferSource) {
                    continue;
                  }
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self._cleanBuffer(sound._node);
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.pause();
                }
              }
            }
            if (!arguments[1]) {
              self._emit("pause", sound ? sound._id : null);
            }
          }
          return self;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(id, internal) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "stop",
              action: function() {
                self.stop(id);
              }
            });
            return self;
          }
          var ids = self._getSoundIds(id);
          for (var i2 = 0; i2 < ids.length; i2++) {
            self._clearTimer(ids[i2]);
            var sound = self._soundById(ids[i2]);
            if (sound) {
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              sound._paused = true;
              sound._ended = true;
              self._stopFade(ids[i2]);
              if (sound._node) {
                if (self._webAudio) {
                  if (sound._node.bufferSource) {
                    if (typeof sound._node.bufferSource.stop === "undefined") {
                      sound._node.bufferSource.noteOff(0);
                    } else {
                      sound._node.bufferSource.stop(0);
                    }
                    self._cleanBuffer(sound._node);
                  }
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.currentTime = sound._start || 0;
                  sound._node.pause();
                  if (sound._node.duration === Infinity) {
                    self._clearSound(sound._node);
                  }
                }
              }
              if (!internal) {
                self._emit("stop", sound._id);
              }
            }
          }
          return self;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(muted, id) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "mute",
              action: function() {
                self.mute(muted, id);
              }
            });
            return self;
          }
          if (typeof id === "undefined") {
            if (typeof muted === "boolean") {
              self._muted = muted;
            } else {
              return self._muted;
            }
          }
          var ids = self._getSoundIds(id);
          for (var i2 = 0; i2 < ids.length; i2++) {
            var sound = self._soundById(ids[i2]);
            if (sound) {
              sound._muted = muted;
              if (sound._interval) {
                self._stopFade(sound._id);
              }
              if (self._webAudio && sound._node) {
                sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.muted = Howler2._muted ? true : muted;
              }
              self._emit("mute", sound._id);
            }
          }
          return self;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var self = this;
          var args = arguments;
          var vol, id;
          if (args.length === 0) {
            return self._volume;
          } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              vol = parseFloat(args[0]);
            }
          } else if (args.length >= 2) {
            vol = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            if (self._state !== "loaded" || self._playLock) {
              self._queue.push({
                event: "volume",
                action: function() {
                  self.volume.apply(self, args);
                }
              });
              return self;
            }
            if (typeof id === "undefined") {
              self._volume = vol;
            }
            id = self._getSoundIds(id);
            for (var i2 = 0; i2 < id.length; i2++) {
              sound = self._soundById(id[i2]);
              if (sound) {
                sound._volume = vol;
                if (!args[2]) {
                  self._stopFade(id[i2]);
                }
                if (self._webAudio && sound._node && !sound._muted) {
                  sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
                } else if (sound._node && !sound._muted) {
                  sound._node.volume = vol * Howler2.volume();
                }
                self._emit("volume", sound._id);
              }
            }
          } else {
            sound = id ? self._soundById(id) : self._sounds[0];
            return sound ? sound._volume : 0;
          }
          return self;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(from, to, len, id) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "fade",
              action: function() {
                self.fade(from, to, len, id);
              }
            });
            return self;
          }
          from = Math.min(Math.max(0, parseFloat(from)), 1);
          to = Math.min(Math.max(0, parseFloat(to)), 1);
          len = parseFloat(len);
          self.volume(from, id);
          var ids = self._getSoundIds(id);
          for (var i2 = 0; i2 < ids.length; i2++) {
            var sound = self._soundById(ids[i2]);
            if (sound) {
              if (!id) {
                self._stopFade(ids[i2]);
              }
              if (self._webAudio && !sound._muted) {
                var currentTime = Howler2.ctx.currentTime;
                var end = currentTime + len / 1e3;
                sound._volume = from;
                sound._node.gain.setValueAtTime(from, currentTime);
                sound._node.gain.linearRampToValueAtTime(to, end);
              }
              self._startFadeInterval(sound, from, to, len, ids[i2], typeof id === "undefined");
            }
          }
          return self;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(sound, from, to, len, id, isGroup) {
          var self = this;
          var vol = from;
          var diff = to - from;
          var steps = Math.abs(diff / 0.01);
          var stepLen = Math.max(4, steps > 0 ? len / steps : len);
          var lastTick = Date.now();
          sound._fadeTo = to;
          sound._interval = setInterval(function() {
            var tick = (Date.now() - lastTick) / len;
            lastTick = Date.now();
            vol += diff * tick;
            vol = Math.round(vol * 100) / 100;
            if (diff < 0) {
              vol = Math.max(to, vol);
            } else {
              vol = Math.min(to, vol);
            }
            if (self._webAudio) {
              sound._volume = vol;
            } else {
              self.volume(vol, sound._id, true);
            }
            if (isGroup) {
              self._volume = vol;
            }
            if (to < from && vol <= to || to > from && vol >= to) {
              clearInterval(sound._interval);
              sound._interval = null;
              sound._fadeTo = null;
              self.volume(to, sound._id);
              self._emit("fade", sound._id);
            }
          }, stepLen);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(id) {
          var self = this;
          var sound = self._soundById(id);
          if (sound && sound._interval) {
            if (self._webAudio) {
              sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
            }
            clearInterval(sound._interval);
            sound._interval = null;
            self.volume(sound._fadeTo, id);
            sound._fadeTo = null;
            self._emit("fade", id);
          }
          return self;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var self = this;
          var args = arguments;
          var loop, id, sound;
          if (args.length === 0) {
            return self._loop;
          } else if (args.length === 1) {
            if (typeof args[0] === "boolean") {
              loop = args[0];
              self._loop = loop;
            } else {
              sound = self._soundById(parseInt(args[0], 10));
              return sound ? sound._loop : false;
            }
          } else if (args.length === 2) {
            loop = args[0];
            id = parseInt(args[1], 10);
          }
          var ids = self._getSoundIds(id);
          for (var i2 = 0; i2 < ids.length; i2++) {
            sound = self._soundById(ids[i2]);
            if (sound) {
              sound._loop = loop;
              if (self._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.loop = loop;
                if (loop) {
                  sound._node.bufferSource.loopStart = sound._start || 0;
                  sound._node.bufferSource.loopEnd = sound._stop;
                  if (self.playing(ids[i2])) {
                    self.pause(ids[i2], true);
                    self.play(ids[i2], true);
                  }
                }
              }
            }
          }
          return self;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var self = this;
          var args = arguments;
          var rate, id;
          if (args.length === 0) {
            id = self._sounds[0]._id;
          } else if (args.length === 1) {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              rate = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            rate = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof rate === "number") {
            if (self._state !== "loaded" || self._playLock) {
              self._queue.push({
                event: "rate",
                action: function() {
                  self.rate.apply(self, args);
                }
              });
              return self;
            }
            if (typeof id === "undefined") {
              self._rate = rate;
            }
            id = self._getSoundIds(id);
            for (var i2 = 0; i2 < id.length; i2++) {
              sound = self._soundById(id[i2]);
              if (sound) {
                if (self.playing(id[i2])) {
                  sound._rateSeek = self.seek(id[i2]);
                  sound._playStart = self._webAudio ? Howler2.ctx.currentTime : sound._playStart;
                }
                sound._rate = rate;
                if (self._webAudio && sound._node && sound._node.bufferSource) {
                  sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
                } else if (sound._node) {
                  sound._node.playbackRate = rate;
                }
                var seek = self.seek(id[i2]);
                var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1e3 - seek;
                var timeout = duration * 1e3 / Math.abs(sound._rate);
                if (self._endTimers[id[i2]] || !sound._paused) {
                  self._clearTimer(id[i2]);
                  self._endTimers[id[i2]] = setTimeout(self._ended.bind(self, sound), timeout);
                }
                self._emit("rate", sound._id);
              }
            }
          } else {
            sound = self._soundById(id);
            return sound ? sound._rate : self._rate;
          }
          return self;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var self = this;
          var args = arguments;
          var seek, id;
          if (args.length === 0) {
            if (self._sounds.length) {
              id = self._sounds[0]._id;
            }
          } else if (args.length === 1) {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else if (self._sounds.length) {
              id = self._sounds[0]._id;
              seek = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            seek = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          if (typeof id === "undefined") {
            return 0;
          }
          if (typeof seek === "number" && (self._state !== "loaded" || self._playLock)) {
            self._queue.push({
              event: "seek",
              action: function() {
                self.seek.apply(self, args);
              }
            });
            return self;
          }
          var sound = self._soundById(id);
          if (sound) {
            if (typeof seek === "number" && seek >= 0) {
              var playing = self.playing(id);
              if (playing) {
                self.pause(id, true);
              }
              sound._seek = seek;
              sound._ended = false;
              self._clearTimer(id);
              if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
                sound._node.currentTime = seek;
              }
              var seekAndEmit = function() {
                if (playing) {
                  self.play(id, true);
                }
                self._emit("seek", id);
              };
              if (playing && !self._webAudio) {
                var emitSeek = function() {
                  if (!self._playLock) {
                    seekAndEmit();
                  } else {
                    setTimeout(emitSeek, 0);
                  }
                };
                setTimeout(emitSeek, 0);
              } else {
                seekAndEmit();
              }
            } else {
              if (self._webAudio) {
                var realTime = self.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
                var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
              } else {
                return sound._node.currentTime;
              }
            }
          }
          return self;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(id) {
          var self = this;
          if (typeof id === "number") {
            var sound = self._soundById(id);
            return sound ? !sound._paused : false;
          }
          for (var i2 = 0; i2 < self._sounds.length; i2++) {
            if (!self._sounds[i2]._paused) {
              return true;
            }
          }
          return false;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(id) {
          var self = this;
          var duration = self._duration;
          var sound = self._soundById(id);
          if (sound) {
            duration = self._sprite[sound._sprite][1] / 1e3;
          }
          return duration;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          var self = this;
          var sounds = self._sounds;
          for (var i2 = 0; i2 < sounds.length; i2++) {
            if (!sounds[i2]._paused) {
              self.stop(sounds[i2]._id);
            }
            if (!self._webAudio) {
              self._clearSound(sounds[i2]._node);
              sounds[i2]._node.removeEventListener("error", sounds[i2]._errorFn, false);
              sounds[i2]._node.removeEventListener(Howler2._canPlayEvent, sounds[i2]._loadFn, false);
              sounds[i2]._node.removeEventListener("ended", sounds[i2]._endFn, false);
              Howler2._releaseHtml5Audio(sounds[i2]._node);
            }
            delete sounds[i2]._node;
            self._clearTimer(sounds[i2]._id);
          }
          var index = Howler2._howls.indexOf(self);
          if (index >= 0) {
            Howler2._howls.splice(index, 1);
          }
          var remCache = true;
          for (i2 = 0; i2 < Howler2._howls.length; i2++) {
            if (Howler2._howls[i2]._src === self._src || self._src.indexOf(Howler2._howls[i2]._src) >= 0) {
              remCache = false;
              break;
            }
          }
          if (cache && remCache) {
            delete cache[self._src];
          }
          Howler2.noAudio = false;
          self._state = "unloaded";
          self._sounds = [];
          self = null;
          return null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(event, fn, id, once) {
          var self = this;
          var events = self["_on" + event];
          if (typeof fn === "function") {
            events.push(once ? { id, fn, once } : { id, fn });
          }
          return self;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(event, fn, id) {
          var self = this;
          var events = self["_on" + event];
          var i2 = 0;
          if (typeof fn === "number") {
            id = fn;
            fn = null;
          }
          if (fn || id) {
            for (i2 = 0; i2 < events.length; i2++) {
              var isId = id === events[i2].id;
              if (fn === events[i2].fn && isId || !fn && isId) {
                events.splice(i2, 1);
                break;
              }
            }
          } else if (event) {
            self["_on" + event] = [];
          } else {
            var keys = Object.keys(self);
            for (i2 = 0; i2 < keys.length; i2++) {
              if (keys[i2].indexOf("_on") === 0 && Array.isArray(self[keys[i2]])) {
                self[keys[i2]] = [];
              }
            }
          }
          return self;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(event, fn, id) {
          var self = this;
          self.on(event, fn, id, 1);
          return self;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(event, id, msg) {
          var self = this;
          var events = self["_on" + event];
          for (var i2 = events.length - 1; i2 >= 0; i2--) {
            if (!events[i2].id || events[i2].id === id || event === "load") {
              setTimeout((function(fn) {
                fn.call(this, id, msg);
              }).bind(self, events[i2].fn), 0);
              if (events[i2].once) {
                self.off(event, events[i2].fn, events[i2].id);
              }
            }
          }
          self._loadQueue(event);
          return self;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(event) {
          var self = this;
          if (self._queue.length > 0) {
            var task = self._queue[0];
            if (task.event === event) {
              self._queue.shift();
              self._loadQueue();
            }
            if (!event) {
              task.action();
            }
          }
          return self;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(sound) {
          var self = this;
          var sprite = sound._sprite;
          if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
            setTimeout(self._ended.bind(self, sound), 100);
            return self;
          }
          var loop = !!(sound._loop || self._sprite[sprite][2]);
          self._emit("end", sound._id);
          if (!self._webAudio && loop) {
            self.stop(sound._id, true).play(sound._id);
          }
          if (self._webAudio && loop) {
            self._emit("play", sound._id);
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._playStart = Howler2.ctx.currentTime;
            var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }
          if (self._webAudio && !loop) {
            sound._paused = true;
            sound._ended = true;
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            self._clearTimer(sound._id);
            self._cleanBuffer(sound._node);
            Howler2._autoSuspend();
          }
          if (!self._webAudio && !loop) {
            self.stop(sound._id, true);
          }
          return self;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(id) {
          var self = this;
          if (self._endTimers[id]) {
            if (typeof self._endTimers[id] !== "function") {
              clearTimeout(self._endTimers[id]);
            } else {
              var sound = self._soundById(id);
              if (sound && sound._node) {
                sound._node.removeEventListener("ended", self._endTimers[id], false);
              }
            }
            delete self._endTimers[id];
          }
          return self;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(id) {
          var self = this;
          for (var i2 = 0; i2 < self._sounds.length; i2++) {
            if (id === self._sounds[i2]._id) {
              return self._sounds[i2];
            }
          }
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var self = this;
          self._drain();
          for (var i2 = 0; i2 < self._sounds.length; i2++) {
            if (self._sounds[i2]._ended) {
              return self._sounds[i2].reset();
            }
          }
          return new Sound2(self);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var self = this;
          var limit = self._pool;
          var cnt = 0;
          var i2 = 0;
          if (self._sounds.length < limit) {
            return;
          }
          for (i2 = 0; i2 < self._sounds.length; i2++) {
            if (self._sounds[i2]._ended) {
              cnt++;
            }
          }
          for (i2 = self._sounds.length - 1; i2 >= 0; i2--) {
            if (cnt <= limit) {
              return;
            }
            if (self._sounds[i2]._ended) {
              if (self._webAudio && self._sounds[i2]._node) {
                self._sounds[i2]._node.disconnect(0);
              }
              self._sounds.splice(i2, 1);
              cnt--;
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(id) {
          var self = this;
          if (typeof id === "undefined") {
            var ids = [];
            for (var i2 = 0; i2 < self._sounds.length; i2++) {
              ids.push(self._sounds[i2]._id);
            }
            return ids;
          } else {
            return [id];
          }
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(sound) {
          var self = this;
          sound._node.bufferSource = Howler2.ctx.createBufferSource();
          sound._node.bufferSource.buffer = cache[self._src];
          if (sound._panner) {
            sound._node.bufferSource.connect(sound._panner);
          } else {
            sound._node.bufferSource.connect(sound._node);
          }
          sound._node.bufferSource.loop = sound._loop;
          if (sound._loop) {
            sound._node.bufferSource.loopStart = sound._start || 0;
            sound._node.bufferSource.loopEnd = sound._stop || 0;
          }
          sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
          return self;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(node) {
          var self = this;
          var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
          if (!node.bufferSource) {
            return self;
          }
          if (Howler2._scratchBuffer && node.bufferSource) {
            node.bufferSource.onended = null;
            node.bufferSource.disconnect(0);
            if (isIOS) {
              try {
                node.bufferSource.buffer = Howler2._scratchBuffer;
              } catch (e2) {
              }
            }
          }
          node.bufferSource = null;
          return self;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(node) {
          var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
          if (!checkIE) {
            node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
          }
        }
      };
      var Sound2 = function(howl) {
        this._parent = howl;
        this.init();
      };
      Sound2.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var self = this;
          var parent = self._parent;
          self._muted = parent._muted;
          self._loop = parent._loop;
          self._volume = parent._volume;
          self._rate = parent._rate;
          self._seek = 0;
          self._paused = true;
          self._ended = true;
          self._sprite = "__default";
          self._id = ++Howler2._counter;
          parent._sounds.push(self);
          self.create();
          return self;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var self = this;
          var parent = self._parent;
          var volume = Howler2._muted || self._muted || self._parent._muted ? 0 : self._volume;
          if (parent._webAudio) {
            self._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
            self._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
            self._node.paused = true;
            self._node.connect(Howler2.masterGain);
          } else if (!Howler2.noAudio) {
            self._node = Howler2._obtainHtml5Audio();
            self._errorFn = self._errorListener.bind(self);
            self._node.addEventListener("error", self._errorFn, false);
            self._loadFn = self._loadListener.bind(self);
            self._node.addEventListener(Howler2._canPlayEvent, self._loadFn, false);
            self._endFn = self._endListener.bind(self);
            self._node.addEventListener("ended", self._endFn, false);
            self._node.src = parent._src;
            self._node.preload = parent._preload === true ? "auto" : parent._preload;
            self._node.volume = volume * Howler2.volume();
            self._node.load();
          }
          return self;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var self = this;
          var parent = self._parent;
          self._muted = parent._muted;
          self._loop = parent._loop;
          self._volume = parent._volume;
          self._rate = parent._rate;
          self._seek = 0;
          self._rateSeek = 0;
          self._paused = true;
          self._ended = true;
          self._sprite = "__default";
          self._id = ++Howler2._counter;
          return self;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var self = this;
          self._parent._emit("loaderror", self._id, self._node.error ? self._node.error.code : 0);
          self._node.removeEventListener("error", self._errorFn, false);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var self = this;
          var parent = self._parent;
          parent._duration = Math.ceil(self._node.duration * 10) / 10;
          if (Object.keys(parent._sprite).length === 0) {
            parent._sprite = { __default: [0, parent._duration * 1e3] };
          }
          if (parent._state !== "loaded") {
            parent._state = "loaded";
            parent._emit("load");
            parent._loadQueue();
          }
          self._node.removeEventListener(Howler2._canPlayEvent, self._loadFn, false);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var self = this;
          var parent = self._parent;
          if (parent._duration === Infinity) {
            parent._duration = Math.ceil(self._node.duration * 10) / 10;
            if (parent._sprite.__default[1] === Infinity) {
              parent._sprite.__default[1] = parent._duration * 1e3;
            }
            parent._ended(self);
          }
          self._node.removeEventListener("ended", self._endFn, false);
        }
      };
      var cache = {};
      var loadBuffer = function(self) {
        var url = self._src;
        if (cache[url]) {
          self._duration = cache[url].duration;
          loadSound(self);
          return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
          var data = atob(url.split(",")[1]);
          var dataView = new Uint8Array(data.length);
          for (var i2 = 0; i2 < data.length; ++i2) {
            dataView[i2] = data.charCodeAt(i2);
          }
          decodeAudioData(dataView.buffer, self);
        } else {
          var xhr = new XMLHttpRequest();
          xhr.open(self._xhr.method, url, true);
          xhr.withCredentials = self._xhr.withCredentials;
          xhr.responseType = "arraybuffer";
          if (self._xhr.headers) {
            Object.keys(self._xhr.headers).forEach(function(key) {
              xhr.setRequestHeader(key, self._xhr.headers[key]);
            });
          }
          xhr.onload = function() {
            var code = (xhr.status + "")[0];
            if (code !== "0" && code !== "2" && code !== "3") {
              self._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
              return;
            }
            decodeAudioData(xhr.response, self);
          };
          xhr.onerror = function() {
            if (self._webAudio) {
              self._html5 = true;
              self._webAudio = false;
              self._sounds = [];
              delete cache[url];
              self.load();
            }
          };
          safeXhrSend(xhr);
        }
      };
      var safeXhrSend = function(xhr) {
        try {
          xhr.send();
        } catch (e2) {
          xhr.onerror();
        }
      };
      var decodeAudioData = function(arraybuffer, self) {
        var error = function() {
          self._emit("loaderror", null, "Decoding audio data failed.");
        };
        var success = function(buffer) {
          if (buffer && self._sounds.length > 0) {
            cache[self._src] = buffer;
            loadSound(self, buffer);
          } else {
            error();
          }
        };
        if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
          Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
        } else {
          Howler2.ctx.decodeAudioData(arraybuffer, success, error);
        }
      };
      var loadSound = function(self, buffer) {
        if (buffer && !self._duration) {
          self._duration = buffer.duration;
        }
        if (Object.keys(self._sprite).length === 0) {
          self._sprite = { __default: [0, self._duration * 1e3] };
        }
        if (self._state !== "loaded") {
          self._state = "loaded";
          self._emit("load");
          self._loadQueue();
        }
      };
      var setupAudioContext = function() {
        if (!Howler2.usingWebAudio) {
          return;
        }
        try {
          if (typeof AudioContext !== "undefined") {
            Howler2.ctx = new AudioContext();
          } else if (typeof webkitAudioContext !== "undefined") {
            Howler2.ctx = new webkitAudioContext();
          } else {
            Howler2.usingWebAudio = false;
          }
        } catch (e2) {
          Howler2.usingWebAudio = false;
        }
        if (!Howler2.ctx) {
          Howler2.usingWebAudio = false;
        }
        var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
        var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
          var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
          if (Howler2._navigator && !safari) {
            Howler2.usingWebAudio = false;
          }
        }
        if (Howler2.usingWebAudio) {
          Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
          Howler2.masterGain.connect(Howler2.ctx.destination);
        }
        Howler2._setup();
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return {
            Howler: Howler2,
            Howl: Howl2
          };
        });
      }
      if (typeof exports !== "undefined") {
        exports.Howler = Howler2;
        exports.Howl = Howl2;
      }
      if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal2;
        global.Howler = Howler2;
        global.Howl = Howl2;
        global.Sound = Sound2;
      } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal2;
        window.Howler = Howler2;
        window.Howl = Howl2;
        window.Sound = Sound2;
      }
    })();
    (function() {
      "use strict";
      HowlerGlobal.prototype._pos = [0, 0, 0];
      HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
      HowlerGlobal.prototype.stereo = function(pan) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        for (var i2 = self._howls.length - 1; i2 >= 0; i2--) {
          self._howls[i2].stereo(pan);
        }
        return self;
      };
      HowlerGlobal.prototype.pos = function(x2, y2, z2) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        y2 = typeof y2 !== "number" ? self._pos[1] : y2;
        z2 = typeof z2 !== "number" ? self._pos[2] : z2;
        if (typeof x2 === "number") {
          self._pos = [x2, y2, z2];
          if (typeof self.ctx.listener.positionX !== "undefined") {
            self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
            self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
            self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
          } else {
            self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
          }
        } else {
          return self._pos;
        }
        return self;
      };
      HowlerGlobal.prototype.orientation = function(x2, y2, z2, xUp, yUp, zUp) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        var or = self._orientation;
        y2 = typeof y2 !== "number" ? or[1] : y2;
        z2 = typeof z2 !== "number" ? or[2] : z2;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x2 === "number") {
          self._orientation = [x2, y2, z2, xUp, yUp, zUp];
          if (typeof self.ctx.listener.forwardX !== "undefined") {
            self.ctx.listener.forwardX.setTargetAtTime(x2, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.forwardY.setTargetAtTime(y2, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.forwardZ.setTargetAtTime(z2, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
          } else {
            self.ctx.listener.setOrientation(x2, y2, z2, xUp, yUp, zUp);
          }
        } else {
          return or;
        }
        return self;
      };
      Howl.prototype.init = /* @__PURE__ */ function(_super) {
        return function(o2) {
          var self = this;
          self._orientation = o2.orientation || [1, 0, 0];
          self._stereo = o2.stereo || null;
          self._pos = o2.pos || null;
          self._pannerAttr = {
            coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : 360,
            coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : 360,
            coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : 0,
            distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : "inverse",
            maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : 1e4,
            panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : "HRTF",
            refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : 1,
            rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : 1
          };
          self._onstereo = o2.onstereo ? [{ fn: o2.onstereo }] : [];
          self._onpos = o2.onpos ? [{ fn: o2.onpos }] : [];
          self._onorientation = o2.onorientation ? [{ fn: o2.onorientation }] : [];
          return _super.call(this, o2);
        };
      }(Howl.prototype.init);
      Howl.prototype.stereo = function(pan, id) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "stereo",
            action: function() {
              self.stereo(pan, id);
            }
          });
          return self;
        }
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        if (typeof id === "undefined") {
          if (typeof pan === "number") {
            self._stereo = pan;
            self._pos = [pan, 0, 0];
          } else {
            return self._stereo;
          }
        }
        var ids = self._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self._soundById(ids[i2]);
          if (sound) {
            if (typeof pan === "number") {
              sound._stereo = pan;
              sound._pos = [pan, 0, 0];
              if (sound._node) {
                sound._pannerAttr.panningModel = "equalpower";
                if (!sound._panner || !sound._panner.pan) {
                  setupPanner(sound, pannerType);
                }
                if (pannerType === "spatial") {
                  if (typeof sound._panner.positionX !== "undefined") {
                    sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                    sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                    sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setPosition(pan, 0, 0);
                  }
                } else {
                  sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                }
              }
              self._emit("stereo", sound._id);
            } else {
              return sound._stereo;
            }
          }
        }
        return self;
      };
      Howl.prototype.pos = function(x2, y2, z2, id) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "pos",
            action: function() {
              self.pos(x2, y2, z2, id);
            }
          });
          return self;
        }
        y2 = typeof y2 !== "number" ? 0 : y2;
        z2 = typeof z2 !== "number" ? -0.5 : z2;
        if (typeof id === "undefined") {
          if (typeof x2 === "number") {
            self._pos = [x2, y2, z2];
          } else {
            return self._pos;
          }
        }
        var ids = self._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self._soundById(ids[i2]);
          if (sound) {
            if (typeof x2 === "number") {
              sound._pos = [x2, y2, z2];
              if (sound._node) {
                if (!sound._panner || sound._panner.pan) {
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(x2, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(y2, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(z2, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(x2, y2, z2);
                }
              }
              self._emit("pos", sound._id);
            } else {
              return sound._pos;
            }
          }
        }
        return self;
      };
      Howl.prototype.orientation = function(x2, y2, z2, id) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "orientation",
            action: function() {
              self.orientation(x2, y2, z2, id);
            }
          });
          return self;
        }
        y2 = typeof y2 !== "number" ? self._orientation[1] : y2;
        z2 = typeof z2 !== "number" ? self._orientation[2] : z2;
        if (typeof id === "undefined") {
          if (typeof x2 === "number") {
            self._orientation = [x2, y2, z2];
          } else {
            return self._orientation;
          }
        }
        var ids = self._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self._soundById(ids[i2]);
          if (sound) {
            if (typeof x2 === "number") {
              sound._orientation = [x2, y2, z2];
              if (sound._node) {
                if (!sound._panner) {
                  if (!sound._pos) {
                    sound._pos = self._pos || [0, 0, -0.5];
                  }
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.orientationX !== "undefined") {
                  sound._panner.orientationX.setValueAtTime(x2, Howler.ctx.currentTime);
                  sound._panner.orientationY.setValueAtTime(y2, Howler.ctx.currentTime);
                  sound._panner.orientationZ.setValueAtTime(z2, Howler.ctx.currentTime);
                } else {
                  sound._panner.setOrientation(x2, y2, z2);
                }
              }
              self._emit("orientation", sound._id);
            } else {
              return sound._orientation;
            }
          }
        }
        return self;
      };
      Howl.prototype.pannerAttr = function() {
        var self = this;
        var args = arguments;
        var o2, id, sound;
        if (!self._webAudio) {
          return self;
        }
        if (args.length === 0) {
          return self._pannerAttr;
        } else if (args.length === 1) {
          if (typeof args[0] === "object") {
            o2 = args[0];
            if (typeof id === "undefined") {
              if (!o2.pannerAttr) {
                o2.pannerAttr = {
                  coneInnerAngle: o2.coneInnerAngle,
                  coneOuterAngle: o2.coneOuterAngle,
                  coneOuterGain: o2.coneOuterGain,
                  distanceModel: o2.distanceModel,
                  maxDistance: o2.maxDistance,
                  refDistance: o2.refDistance,
                  rolloffFactor: o2.rolloffFactor,
                  panningModel: o2.panningModel
                };
              }
              self._pannerAttr = {
                coneInnerAngle: typeof o2.pannerAttr.coneInnerAngle !== "undefined" ? o2.pannerAttr.coneInnerAngle : self._coneInnerAngle,
                coneOuterAngle: typeof o2.pannerAttr.coneOuterAngle !== "undefined" ? o2.pannerAttr.coneOuterAngle : self._coneOuterAngle,
                coneOuterGain: typeof o2.pannerAttr.coneOuterGain !== "undefined" ? o2.pannerAttr.coneOuterGain : self._coneOuterGain,
                distanceModel: typeof o2.pannerAttr.distanceModel !== "undefined" ? o2.pannerAttr.distanceModel : self._distanceModel,
                maxDistance: typeof o2.pannerAttr.maxDistance !== "undefined" ? o2.pannerAttr.maxDistance : self._maxDistance,
                refDistance: typeof o2.pannerAttr.refDistance !== "undefined" ? o2.pannerAttr.refDistance : self._refDistance,
                rolloffFactor: typeof o2.pannerAttr.rolloffFactor !== "undefined" ? o2.pannerAttr.rolloffFactor : self._rolloffFactor,
                panningModel: typeof o2.pannerAttr.panningModel !== "undefined" ? o2.pannerAttr.panningModel : self._panningModel
              };
            }
          } else {
            sound = self._soundById(parseInt(args[0], 10));
            return sound ? sound._pannerAttr : self._pannerAttr;
          }
        } else if (args.length === 2) {
          o2 = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          sound = self._soundById(ids[i2]);
          if (sound) {
            var pa = sound._pannerAttr;
            pa = {
              coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : pa.coneInnerAngle,
              coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : pa.coneOuterAngle,
              coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : pa.coneOuterGain,
              distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : pa.distanceModel,
              maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : pa.maxDistance,
              refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : pa.refDistance,
              rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : pa.rolloffFactor,
              panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : pa.panningModel
            };
            var panner = sound._panner;
            if (!panner) {
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }
              setupPanner(sound, "spatial");
              panner = sound._panner;
            }
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          }
        }
        return self;
      };
      Sound.prototype.init = /* @__PURE__ */ function(_super) {
        return function() {
          var self = this;
          var parent = self._parent;
          self._orientation = parent._orientation;
          self._stereo = parent._stereo;
          self._pos = parent._pos;
          self._pannerAttr = parent._pannerAttr;
          _super.call(this);
          if (self._stereo) {
            parent.stereo(self._stereo);
          } else if (self._pos) {
            parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
          }
        };
      }(Sound.prototype.init);
      Sound.prototype.reset = /* @__PURE__ */ function(_super) {
        return function() {
          var self = this;
          var parent = self._parent;
          self._orientation = parent._orientation;
          self._stereo = parent._stereo;
          self._pos = parent._pos;
          self._pannerAttr = parent._pannerAttr;
          if (self._stereo) {
            parent.stereo(self._stereo);
          } else if (self._pos) {
            parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
          } else if (self._panner) {
            self._panner.disconnect(0);
            self._panner = void 0;
            parent._refreshBuffer(self);
          }
          return _super.call(this);
        };
      }(Sound.prototype.reset);
      var setupPanner = function(sound, type) {
        type = type || "spatial";
        if (type === "spatial") {
          sound._panner = Howler.ctx.createPanner();
          sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
          sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
          sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
          sound._panner.distanceModel = sound._pannerAttr.distanceModel;
          sound._panner.maxDistance = sound._pannerAttr.maxDistance;
          sound._panner.refDistance = sound._pannerAttr.refDistance;
          sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
          sound._panner.panningModel = sound._pannerAttr.panningModel;
          if (typeof sound._panner.positionX !== "undefined") {
            sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
            sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
            sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
          }
          if (typeof sound._panner.orientationX !== "undefined") {
            sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
            sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
            sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
          }
        } else {
          sound._panner = Howler.ctx.createStereoPanner();
          sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
        }
        sound._panner.connect(sound._node);
        if (!sound._paused) {
          sound._parent.pause(sound._id, true).play(sound._id, true);
        }
      };
    })();
  }
});

// node_modules/react-sounds/dist/index.esm.js
var import_howler = __toESM(require_howler());
var import_react = __toESM(require_react());
var s = { version: "1.0.0", sounds: { "ambient/campfire": { src: "ambient/campfire.eb676cb.mp3", duration: 22.047313 }, "ambient/heartbeat": { src: "ambient/heartbeat.3680f81.mp3", duration: 22.047313 }, "ambient/rain": { src: "ambient/rain.96a6bc5.mp3", duration: 22.047313 }, "ambient/water_stream": { src: "ambient/water_stream.9383548.mp3", duration: 22.047313 }, "ambient/wind": { src: "ambient/wind.13b95c3.mp3", duration: 22.047313 }, "arcade/coin": { src: "arcade/coin.5ec00e3.mp3", duration: 0.862 }, "arcade/coin_bling": { src: "arcade/coin_bling.e7e6644.mp3", duration: 0.862 }, "arcade/jump": { src: "arcade/jump.6baf978.mp3", duration: 0.862 }, "arcade/level_down": { src: "arcade/level_down.7f42195.mp3", duration: 1.123265 }, "arcade/level_up": { src: "arcade/level_up.0aba301.mp3", duration: 1.48898 }, "arcade/power_down": { src: "arcade/power_down.222ab81.mp3", duration: 1.071 }, "arcade/power_up": { src: "arcade/power_up.bcafcc5.mp3", duration: 1.071 }, "arcade/upgrade": { src: "arcade/upgrade.1da1db4.mp3", duration: 0.862 }, "game/coin": { src: "game/coin.21575b3.mp3", duration: 0.914286 }, "game/hit": { src: "game/hit.7f64763.mp3", duration: 0.313469 }, "game/miss": { src: "game/miss.b1d5a19.mp3", duration: 0.287347 }, "game/portal_closing": { src: "game/portal_closing.f434407.mp3", duration: 2.08975 }, "game/portal_opening": { src: "game/portal_opening.54935de.mp3", duration: 3.474286 }, "game/void": { src: "game/void.ab99118.mp3", duration: 0.862 }, "misc/silence": { src: "misc/silence.01e0b9b.mp3", duration: 1.152 }, "notification/completed": { src: "notification/completed.31e527e.mp3", duration: 0.862 }, "notification/error": { src: "notification/error.b92d3c6.mp3", duration: 0.548563 }, "notification/info": { src: "notification/info.fc3baa4.mp3", duration: 0.862 }, "notification/message": { src: "notification/message.1eefe18.mp3", duration: 0.862 }, "notification/notification": { src: "notification/notification.595d086.mp3", duration: 0.862 }, "notification/popup": { src: "notification/popup.cf74b54.mp3", duration: 0.313469 }, "notification/reminder": { src: "notification/reminder.6d68587.mp3", duration: 0.862 }, "notification/success": { src: "notification/success.f38c2ed.mp3", duration: 1.227755 }, "notification/warning": { src: "notification/warning.207aed9.mp3", duration: 0.862 }, "system/boot_down": { src: "system/boot_down.7baf040.mp3", duration: 1.593469 }, "system/boot_up": { src: "system/boot_up.7369806.mp3", duration: 3.134694 }, "system/device_connect": { src: "system/device_connect.e609d62.mp3", duration: 0.862 }, "system/device_disconnect": { src: "system/device_disconnect.bd814fa.mp3", duration: 0.862 }, "system/lock": { src: "system/lock.4063aab.mp3", duration: 0.862 }, "system/screenshot": { src: "system/screenshot.f3483cb.mp3", duration: 0.235102 }, "system/trash": { src: "system/trash.ed51a4e.mp3", duration: 0.862 }, "ui/blocked": { src: "ui/blocked.be40409.mp3", duration: 0.940408 }, "ui/button_hard": { src: "ui/button_hard.011f516.mp3", duration: 0.835918 }, "ui/button_hard_double": { src: "ui/button_hard_double.2c7e778.mp3", duration: 0.862 }, "ui/button_medium": { src: "ui/button_medium.f1076ea.mp3", duration: 0.862 }, "ui/button_soft": { src: "ui/button_soft.896771c.mp3", duration: 0.862 }, "ui/button_soft_double": { src: "ui/button_soft_double.ef0aec4.mp3", duration: 0.862 }, "ui/button_squishy": { src: "ui/button_squishy.69c5c9a.mp3", duration: 0.391837 }, "ui/buzz": { src: "ui/buzz.6d6857f.mp3", duration: 0.548563 }, "ui/buzz_deep": { src: "ui/buzz_deep.c1f597f.mp3", duration: 0.809796 }, "ui/buzz_long": { src: "ui/buzz_long.d506d81.mp3", duration: 1.071 }, "ui/copy": { src: "ui/copy.4aadb27.mp3", duration: 0.130612 }, "ui/input_blur": { src: "ui/input_blur.607531b.mp3", duration: 0.862 }, "ui/input_focus": { src: "ui/input_focus.80b402e.mp3", duration: 0.287347 }, "ui/item_deselect": { src: "ui/item_deselect.9955ec7.mp3", duration: 0.862 }, "ui/item_select": { src: "ui/item_select.5d88832.mp3", duration: 0.862 }, "ui/keystroke_hard": { src: "ui/keystroke_hard.6d8eb42.mp3", duration: 0.548563 }, "ui/keystroke_medium": { src: "ui/keystroke_medium.2b4ae6c.mp3", duration: 0.548563 }, "ui/keystroke_soft": { src: "ui/keystroke_soft.fcd4503.mp3", duration: 0.548563 }, "ui/panel_collapse": { src: "ui/panel_collapse.1b8441f.mp3", duration: 0.862 }, "ui/panel_expand": { src: "ui/panel_expand.ef3ca39.mp3", duration: 0.862 }, "ui/pop_close": { src: "ui/pop_close.1f2dc35.mp3", duration: 0.809796 }, "ui/pop_open": { src: "ui/pop_open.360c640.mp3", duration: 0.835918 }, "ui/popup_close": { src: "ui/popup_close.1bd2a1b.mp3", duration: 1.071 }, "ui/popup_open": { src: "ui/popup_open.97597a8.mp3", duration: 1.071 }, "ui/radio_select": { src: "ui/radio_select.4fbe4e3.mp3", duration: 0.862 }, "ui/send": { src: "ui/send.396090f.mp3", duration: 0.182857 }, "ui/submit": { src: "ui/submit.1e228b1.mp3", duration: 0.548563 }, "ui/success_bling": { src: "ui/success_bling.3f44a2f.mp3", duration: 0.809796 }, "ui/success_blip": { src: "ui/success_blip.911b304.mp3", duration: 0.626939 }, "ui/success_chime": { src: "ui/success_chime.436ed4a.mp3", duration: 1.619592 }, "ui/tab_close": { src: "ui/tab_close.3c1a646.mp3", duration: 0.548563 }, "ui/tab_open": { src: "ui/tab_open.3745bcd.mp3", duration: 0.548563 }, "ui/toggle_off": { src: "ui/toggle_off.7103845.mp3", duration: 0.261224 }, "ui/toggle_on": { src: "ui/toggle_on.2f87bf7.mp3", duration: 0.287347 }, "ui/window_close": { src: "ui/window_close.0e958da.mp3", duration: 0.548563 }, "ui/window_open": { src: "ui/window_open.7478756.mp3", duration: 0.548563 } } };
function d(n2) {
  return n2 in s.sounds;
}
var p = "https://reacticons.sfo3.cdn.digitaloceanspaces.com/v1";
var l = true;
var m = [];
var f = false;
function b(n2) {
  p = n2;
}
function _() {
  return p;
}
var w = {};
var h = {};
function y(o2) {
  return async () => (w[o2] || (w[o2] = k(o2)), async function(o3) {
    if (h[o3]) return h[o3];
    w[o3] || (w[o3] = k(o3));
    const t2 = await w[o3], e2 = URL.createObjectURL(t2), r2 = new import_howler.Howl({ src: [e2], format: ["mp3"], html5: true, onload: () => {
      r2._objectUrl = e2;
    } });
    return h[o3] = { instance: r2, subscriptions: 0 }, h[o3];
  }(o2));
}
async function g(n2) {
  const o2 = await y(n2)();
  return o2.subscriptions += 1, o2.instance;
}
function v(n2) {
  const o2 = h[n2];
  return o2 && o2.subscriptions > 0 && (o2.subscriptions -= 1), function(n3) {
    const o3 = h[n3];
    if (!o3 || o3.instance.playing() || o3.subscriptions > 0) return;
    const { instance: t2 } = o3;
    t2._objectUrl && URL.revokeObjectURL(t2._objectUrl);
    t2.unload(), delete h[n3];
  }(n2), null;
}
async function k(n2) {
  try {
    const o3 = await async function(n3) {
      var o4;
      if (!d(n3)) return n3;
      const t3 = `/sounds/${n3}.mp3`;
      try {
        const n4 = new AbortController(), e3 = setTimeout(() => n4.abort(), 300), r2 = await fetch(t3, { method: "HEAD", signal: n4.signal });
        return clearTimeout(e3), r2.ok && (null === (o4 = r2.headers.get("content-type")) || void 0 === o4 ? void 0 : o4.toLowerCase().startsWith("audio")) ? t3 : null;
      } catch (n4) {
      }
      return null;
    }(n2);
    if (o3) {
      const n3 = await fetch(o3);
      if (n3.ok) return await n3.blob();
    }
  } catch (o3) {
    console.warn(`Error loading local sound "${n2}", falling back to CDN:`, o3);
  }
  if (!d(n2)) throw new Error(`Failed to load custom sound "${n2}"`);
  const o2 = s.sounds[n2], t2 = `${p}/${o2.src}`, e2 = await fetch(t2);
  if (!e2.ok) throw new Error(`Failed to fetch sound "${n2}" from CDN`);
  return await e2.blob();
}
function E(n2) {
  return Promise.all(n2.map(async (n3) => {
    w[n3] || (w[n3] = k(n3)), await w[n3];
  }));
}
async function z(n2, o2) {
  if (!L()) return;
  const t2 = await g(n2);
  let e2 = false;
  o2 && (void 0 !== o2.volume && t2.volume(o2.volume), void 0 !== o2.rate && t2.rate(o2.rate), void 0 !== o2.loop && t2.loop(o2.loop)), t2.on("end", () => {
    e2 || (null == o2 ? void 0 : o2.loop) || (v(n2), e2 = true);
  }), t2.play();
}
function L() {
  return "undefined" != typeof window && l;
}
function x(n2) {
  l = n2, "undefined" != typeof localStorage && localStorage.setItem("react-sounds-enabled", n2 ? "true" : "false"), m.forEach((o2) => o2(n2));
}
async function S() {
  if ("undefined" != typeof window && import_howler.Howler.ctx && "suspended" === import_howler.Howler.ctx.state) try {
    await import_howler.Howler.ctx.resume();
  } catch (n2) {
    console.warn("Failed to unlock audio context:", n2);
  }
}
var j;
function P(n2, o2 = {}) {
  const [t2, u2] = (0, import_react.useState)(false), [s2, d2] = (0, import_react.useState)(false), p2 = (0, import_react.useRef)(null), l2 = (0, import_react.useRef)([]);
  let m2 = L();
  try {
    const n3 = j ? (0, import_react.useContext)(j) : null;
    n3 && (m2 = n3.enabled);
  } catch (n3) {
  }
  const f2 = (0, import_react.useCallback)(async () => {
    if (p2.current) return p2.current;
    try {
      const o3 = await g(n2);
      return o3.on("end", (o4) => {
        const t3 = l2.current.findIndex((n3) => n3.id === o4);
        if (t3 >= 0) {
          const n3 = l2.current[t3];
          n3.resolver && n3.resolver(), n3.loop || l2.current.splice(t3, 1);
        }
        0 === l2.current.length && (p2.current = v(n2), d2(false));
      }), p2.current = o3, u2(true), o3;
    } catch (n3) {
      throw console.error("Error loading sound:", n3), n3;
    }
  }, [n2, d2]), b2 = (0, import_react.useCallback)(async (n3 = o2) => {
    if (m2) try {
      await S();
      const o3 = await f2(), t3 = void 0 !== n3.loop && n3.loop;
      void 0 !== n3.volume && o3.volume(n3.volume), void 0 !== n3.rate && o3.rate(n3.rate), o3.loop(t3);
      const e2 = o3.play();
      return d2(true), t3 ? void l2.current.push({ id: e2, loop: t3 }) : new Promise((n4) => {
        l2.current.push({ id: e2, loop: t3, resolver: () => n4() });
      });
    } catch (n4) {
      throw console.error("Error playing sound:", n4), n4;
    }
  }, [o2, m2, f2, t2]), _2 = (0, import_react.useCallback)(() => {
    p2.current && (l2.current.forEach((n3) => {
      n3.resolver && n3.resolver();
    }), p2.current.stop(), p2.current = v(n2), l2.current = [], d2(false));
  }, []), w2 = (0, import_react.useCallback)(() => {
    p2.current && (p2.current.pause(), d2(false));
  }, []), h2 = (0, import_react.useCallback)(() => {
    p2.current && m2 && 0 !== l2.current.length && S().then(() => {
      l2.current.forEach(({ id: n3 }) => {
        var o3;
        return null === (o3 = p2.current) || void 0 === o3 ? void 0 : o3.play(n3);
      }), d2(true);
    });
  }, [m2]);
  return (0, import_react.useEffect)(() => {
    !m2 && s2 && w2();
  }, [m2, s2, w2]), (0, import_react.useEffect)(() => (E([n2]).then(() => u2(true)), () => {
    u2(false), d2(false), l2.current.forEach((n3) => {
      n3.resolver && n3.resolver();
    }), l2.current = [], p2.current && (p2.current.stop(), p2.current = v(n2));
  }), [n2]), { play: b2, stop: _2, pause: w2, resume: h2, isPlaying: s2, isLoaded: t2 };
}
function U(n2, o2, t2) {
  const { play: e2 } = P(n2), i2 = (0, import_react.useRef)(true);
  (0, import_react.useEffect)(() => {
    const n3 = i2.current && false === (null == t2 ? void 0 : t2.initial);
    i2.current = false, n3 || e2(t2).catch((n4) => console.error("Failed to play sound:", n4));
  }, [o2]);
}
function C() {
  const n2 = (0, import_react.useContext)(j);
  if (!n2) throw new Error("useSoundEnabled must be used within a SoundProvider");
  return [n2.enabled, n2.setEnabled];
}
function $({ name: n2, trigger: o2 = "none", options: e2, children: r2, onLoad: i2, onPlay: c2, onStop: u2, onError: s2 }) {
  const { play: d2, stop: p2, isLoaded: l2, isPlaying: m2 } = P(n2, e2);
  return (0, import_react.useEffect)(() => {
    l2 && i2 && i2();
  }, [l2, i2]), (0, import_react.useEffect)(() => {
    m2 && c2 && c2();
  }, [m2, c2]), (0, import_react.useEffect)(() => ("mount" === o2 && d2(e2).catch((n3) => {
    s2 && s2(n3);
  }), () => {
    "unmount" === o2 && z(n2, e2), p2(), u2 && u2();
  }), [o2, n2, d2, p2, u2, e2, s2]), import_react.default.createElement(import_react.default.Fragment, null, r2);
}
function F({ sound: n2, soundOptions: o2, children: e2, onClick: r2, onSoundError: i2, ...c2 }) {
  const { play: a2 } = P(n2, o2);
  return import_react.default.createElement("button", { onClick: (n3) => {
    a2().catch((n4) => {
      i2 && i2(n4);
    }), r2 && r2(n3);
  }, ...c2 }, e2);
}
!function() {
  if ("undefined" == typeof localStorage) return;
  const n2 = localStorage.getItem("react-sounds-enabled");
  null !== n2 && (l = "false" !== n2);
}(), "undefined" != typeof window && function() {
  if ("undefined" == typeof window || f) return () => {
  };
  f = true;
  const n2 = ["click", "touchstart", "keydown"], o2 = () => {
    S(), n2.forEach((n3) => document.removeEventListener(n3, o2));
  };
  n2.forEach((n3) => document.addEventListener(n3, o2));
}();
var O = (0, import_react.createContext)(null);
function R({ preload: n2 = [], initialEnabled: o2, children: r2 }) {
  const [i2, u2] = (0, import_react.useState)(() => void 0 !== o2 ? o2 : L()), s2 = (0, import_react.useCallback)((n3) => {
    x(n3);
  }, []);
  return (0, import_react.useEffect)(() => {
    return n3 = (n4) => {
      u2(n4);
    }, m.push(n3), () => {
      const o3 = m.indexOf(n3);
      -1 !== o3 && m.splice(o3, 1);
    };
    var n3;
  }, []), (0, import_react.useEffect)(() => {
    S();
  }, []), (0, import_react.useEffect)(() => {
    if (n2.length > 0) {
      E(n2).catch((n3) => {
        console.error("Error preloading sounds:", n3);
      });
    }
  }, [n2]), import_react.default.createElement(O.Provider, { value: { enabled: i2, setEnabled: s2 } }, r2);
}
j = O;
export {
  $ as Sound,
  F as SoundButton,
  R as SoundProvider,
  k as fetchSoundBlob,
  _ as getCDNUrl,
  L as isSoundEnabled,
  y as makeRemoteSound,
  z as playSound,
  E as preloadSounds,
  b as setCDNUrl,
  x as setSoundEnabled,
  P as useSound,
  C as useSoundEnabled,
  U as useSoundOnChange
};
/*! Bundled license information:

howler/dist/howler.js:
  (*!
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
*/
//# sourceMappingURL=react-sounds.js.map
